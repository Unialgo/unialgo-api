# Product Requirements Document: Integração com Judge0 para Avaliação de Código

## 1. Visão Geral

Este documento detalha os requisitos para integrar a plataforma de avaliação de código Judge0 ao `unialgo-api`. O objetivo principal é permitir que estudantes submetam soluções de código para problemas de programação e recebam feedback automatizado e em tempo real sobre a correção e eficiência de suas soluções. A integração deve ser robusta, segura e se alinhar aos princípios SOLID e à arquitetura existente do sistema UniAlgo.

## 2. Componentes Principais e Modificações

### 2.1. Backend (`unialgo-api`)

#### 2.1.1. Módulo `question`
* **Entidade `Question` (`src/main/java/com/ua/unialgo/question/entity/Question.java`):**
    * Será necessário adicionar campos para vincular a questão a um problema específico no Judge0, se houver um ID externo.
    * Considerar a necessidade de um campo `language` ou `allowedLanguages` para a questão, indicando as linguagens de programação aceitas para a submissão.
* **Entidade `TestCase` (`src/main/java/com/ua/unialgo/question/entity/TestCase.java`):**
    * `TestCase` já possui `input` e `expectedOutput`. Estes serão cruciais para a comunicação com Judge0.
    * Considerar adicionar um campo para `hidden` (testes públicos vs. privados), se aplicável.
* **Serviço `QuestionService` (`src/main/java/com/ua/unialgo/question/service/QuestionService.java`):**
    * Métodos CRUD existentes serão adaptados para considerar os novos campos da `Question` e `TestCase`.

#### 2.1.2. Novo Módulo `submission` (Sugestão: `com.ua.unialgo.submission`)
* **Entidade `Submission`:**
    * ID (Gerado automaticamente)
    * `User` (Aluno que fez a submissão)
    * `Question` (Questão à qual a submissão se refere)
    * `sourceCode` (Código submetido pelo aluno)
    * `languageId` (ID da linguagem conforme Judge0)
    * `status` (Status da avaliação: `PENDING`, `ACCEPTED`, `WRONG_ANSWER`, `TIME_LIMIT_EXCEEDED`, `COMPILATION_ERROR`, etc.)
    * `stdout` (Saída padrão da execução do código)
    * `stderr` (Erro padrão da execução do código, e.g. `runtime error`)
    * `compileOutput` (Saída do compilador, e.g. `compilation error`)
    * `memory` (Consumo de memória em bytes)
    * `time` (Tempo de execução em segundos)
    * `submissionDate` (Timestamp da submissão)
* **Controlador `SubmissionController`:**
    * Endpoint para `/submissions` (POST):
        * Receber `sourceCode`, `languageId` e `questionId` de um aluno.
        * Autenticação: Apenas `ROLE_STUDENT` pode submeter.
        * Validar se o aluno está autorizado a submeter para aquela questão/assignment.
        * Persistir a submissão no banco de dados com status `PENDING`.
        * Chamar o `Judge0Service` para enviar a submissão ao Judge0.
        * Retornar um ID da submissão para o cliente.
    * Endpoint para `/submissions/{id}` (GET):
        * Permitir que um aluno veja o status e os detalhes de sua própria submissão.
        * Permitir que um professor veja qualquer submissão para suas questões.
* **Serviço `SubmissionService`:**
    * Lógica de negócio para gerenciar submissões.
    * Persistir e atualizar a entidade `Submission`.
    * Validar regras de negócio (e.g., aluno pode submeter para esta questão?).
* **Repositório `SubmissionRepository`:**
    * Interface para acesso a dados da entidade `Submission`.

#### 2.1.3. Novo Módulo `judge0` (Sugestão: `com.ua.unialgo.judge0`)
* **Serviço `Judge0Service`:**
    * Responsável pela comunicação direta com a API Judge0.
    * Método `submitCode(Submission submission, List<TestCase> testCases)`:
        * Construir o payload da requisição para Judge0, incluindo `source_code`, `language_id`, e `test_cases` (com `stdin` e `expected_output`).
        * Fazer a chamada HTTP para o endpoint `/submissions` do Judge0.
        * Processar a resposta inicial do Judge0 (que pode ser um token de submissão).
        * Retornar o token do Judge0 ou o resultado inicial.
    * Método `getSubmissionStatus(String token)`:
        * Fazer chamadas periódicas (polling) para o endpoint `/submissions/{token}` do Judge0.
        * Atualizar o status e os detalhes da `Submission` no banco de dados do UniAlgo com os resultados da avaliação do Judge0.
        * Este método pode ser acionado por um mecanismo assíncrono (e.g., `@Async`, Spring Cloud Stream com RabbitMQ/Kafka, ou um `Scheduler`).
* **DTOs para comunicação com Judge0:**
    * `Judge0SubmissionRequestDto` (para enviar código e testes).
    * `Judge0SubmissionResponseDto` (para receber token da submissão).
    * `Judge0StatusResponseDto` (para receber o resultado completo da avaliação).
    * Modelos para a estrutura de resultados de testes do Judge0.
* **Configuração `Judge0Config` (Analogamente a `AIConfig.java`):**
    * Propriedades para `judge0.api.url`, `judge0.api.key` (se aplicável), `judge0.default-language-id`, etc. Lidas de variáveis de ambiente.

### 2.2. Infraestrutura (Docker Compose)

* **`compose.yml`:**
    * Adicionar um serviço Docker para o Judge0.
    * Configurar a imagem do Judge0 (ex: `glot/judge0:latest` ou uma imagem específica).
    * Expor a porta da API do Judge0 (ex: `2358:2358`).
    * Configurar volumes persistentes para dados do Judge0, se necessário.
    * Garantir que o `unialgo-api` possa se comunicar com o serviço Judge0 (nomes de host na rede Docker).

### 2.3. Banco de Dados (Liquibase)

* **Novas `changelogs` Liquibase (`src/main/resources/db`):**
    * Criar script para a tabela `Submission` (e quaisquer outras tabelas auxiliares que o Judge0 possa exigir, embora geralmente não).
    * Migrações para adicionar os novos campos às tabelas `Question` e `TestCase`, se aplicável.

## 3. Fluxo de Integração

1.  **Estudante Submete Código:** Estudante envia código-fonte, ID da questão e ID da linguagem para `/submissions` no `SubmissionController`.
2.  **Persistência Inicial:** `SubmissionService` salva a submissão com status `PENDING`.
3.  **Envio ao Judge0:** `SubmissionService` chama `Judge0Service.submitCode()` com o código e os `TestCases` associados à `Question`.
4.  **Polling/Webhook:**
    * **Abordagem Inicial (Polling):** `Judge0Service` inicia um loop de polling (ou um `Scheduler` separado) para consultar o status da submissão no Judge0 usando o token retornado.
    * **Melhoria Futura (Webhook):** Judge0 pode ser configurado para enviar um webhook para o `unialgo-api` quando a avaliação estiver concluída, eliminando o polling (mais eficiente).
5.  **Atualização do Status:** Quando o Judge0 retorna o resultado final, `Judge0Service` atualiza a `Submission` no banco de dados com o status final, tempo, memória, stdout, stderr, etc.
6.  **Notificação (Opcional):** O sistema pode notificar o aluno sobre o resultado da avaliação (e.g., via WebSocket, e-mail, notificação in-app).

## 4. Princípios SOLID e Padrões de Design Aplicados

* **SRP (Single Responsibility Principle):**
    * Criação de novos serviços (`SubmissionService`, `Judge0Service`) com responsabilidades bem definidas.
    * `SubmissionService`: Gerencia ciclo de vida da submissão no sistema UniAlgo.
    * `Judge0Service`: Encapsula a comunicação e o contrato com a API externa do Judge0.
* **OCP (Open/Closed Principle):**
    * A arquitetura deve permitir a adição de novas linguagens de programação ou diferentes tipos de avaliadores de código (além do Judge0) sem modificar o código existente nos módulos principais. A abstração no `Judge0Service` ajuda nisso.
* **LSP (Liskov Substitution Principle):**
    * Garantir que as entidades e DTOs recém-criadas se comportem de forma consistente com suas abstrações ou classes base.
* **ISP (Interface Segregation Principle):**
    * Interfaces no `submission` e `judge0` devem ser coesas e específicas para seus clientes.
* **DIP (Dependency Inversion Principle):**
    * `SubmissionService` deve depender de abstrações (`Judge0Service` via interface, se necessário) em vez de uma implementação concreta direta, facilitando a troca ou mock do avaliador de código.
* **Padrão de Design "Client" ou "Gateway":** O `Judge0Service` atua como um *client* ou *gateway* para a API externa do Judge0, traduzindo as requisições internas para o formato da API externa e vice-versa.
* **Padrão de Design "DTO":** Uso contínuo de DTOs para comunicação segura e desacoplada entre camadas e com a API externa.

## 5. Riscos e Mitigações

* **Latência da Avaliação:** Avaliações de código podem demorar. O polling excessivo pode sobrecarregar a API do Judge0 ou o backend.
    * **Mitigação:** Implementar polling com backoff exponencial ou, idealmente, configurar um webhook no Judge0 para notificação assíncrona.
* **Segurança da Execução de Código:** Rodar código de usuário é um risco de segurança (execução maliciosa, loop infinito, etc.).
    * **Mitigação:** Judge0 é projetado para execução segura em *sandboxes*, mas a configuração correta do ambiente Docker é vital. Implementar limites de tempo e memória nas submissões.
* **Disponibilidade do Judge0:** Se o serviço Judge0 cair, as avaliações param.
    * **Mitigação:** Implementar *circuit breakers* e *retries* no `Judge0Service`. Notificação de falhas para administradores.
* **Consistência de Dados:** Garantir que o status da submissão esteja sempre sincronizado.
    * **Mitigação:** Transações adequadas, idempotência nas chamadas ao Judge0, e mecanismos de retry.
* **Configuração de Credenciais:** As chaves de API e URLs do Judge0 devem ser tratadas como segredos.
    * **Mitigação:** Uso de variáveis de ambiente (`.env`) e exclusão de arquivos de configuração do controle de versão (`.gitignore`), conforme já discutido.

## 6. Roadmap de Desenvolvimento (Visão Inicial para Tarefas)

1.  **Configuração de Infraestrutura:**
    * Adicionar serviço Judge0 ao `compose.yml`.
    * Garantir que o `unialgo-api` pode se comunicar com o Judge0.
2.  **Módulo Judge0 Core:**
    * Criar DTOs para comunicação com Judge0.
    * Implementar `Judge0Service` com métodos básicos `submitCode` e `getSubmissionStatus`.
    * Configurar `Judge0Config` e carregar variáveis de ambiente.
3.  **Módulo Submission:**
    * Criar entidade `Submission` e repositório.
    * Implementar `SubmissionService` (salvar, atualizar status).
    * Implementar `SubmissionController` (endpoints POST e GET).
    * Ajustar `Question` e `TestCase` para novos campos (se aplicável).
4.  **Lógica de Avaliação:**
    * Integrar `SubmissionController` com `Judge0Service`.
    * Implementar lógica de polling (ou webhook, se avançar para isso) no `Judge0Service` para atualizar o status da submissão.
5.  **Testes e Refinamento:**
    * Testes unitários e de integração para os novos módulos.
    * Testes de segurança e performance.
    * Refinar prompts de `AIService` para `Judge0Service` se a geração de enunciados precisar de informações mais específicas para avaliação.

---

**Agora que o PRD está pronto, Enzo, o próximo passo é usar o Task Master CLI para "parseá-lo" e gerar as tarefas iniciais.**

No terminal (na raiz do seu projeto `unialgo-api`):

```bash
task-master parse-prd scripts/judge0_integration.prd